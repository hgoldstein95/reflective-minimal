{-# LANGUAGE GADTs #-}

module Examples.BSTHoles where

import Data.Maybe (maybeToList)
import Interps (generate)
import Reflectives hiding (bst)
import qualified Test.QuickCheck as QC

bst :: (Int, Int) -> Reflective Tree Tree
bst (lo, hi) | lo > hi = comap undefined $ return Leaf
bst (lo, hi) =
  frequency
    [ (1, comap undefined $ return Leaf),
      ( 5,
        do
          x <- comap undefined $ choose (lo, hi)
          l <- comap undefined $ bst (lo, x - 1)
          r <- comap undefined $ bst (x + 1, hi)
          return (Node l x r)
      )
    ]

reflect' :: Reflective b a -> b -> [a]
reflect' g v = interp g v Nothing
  where
    -- ref -> value -> maybe size -> values
    interp :: Reflective b a -> b -> Maybe Int -> [a]
    interp (Return x) _ _ = return x
    interp (Bind x f) b s = interpR x b s >>= \y -> interp (f y) b s

    interpR :: R b a -> b -> Maybe Int -> [a]
    interpR (Pick xs) b s = concat [interp x b s | (_, _, x) <- xs]
    interpR (Lmap f x) b s = interpR x (f b) s
    interpR (Prune x) b s = maybeToList b >>= \b' -> interpR x b' s
    interpR (ChooseInteger (lo, hi)) b _
      | lo <= b && b <= hi = pure b
      | otherwise = []
    interpR GetSize _ (Just s) = return s
    interpR GetSize _ Nothing = pure 30
    interpR (Resize s x) b _ = interpR x b (Just s)

soundness :: Show a => Reflective a a -> QC.NonNegative Int -> QC.Property
soundness g n =
  QC.forAll
    (generate (resize (QC.getNonNegative n) g))
    (not . null . reflect' (resize (QC.getNonNegative n) g))

-- a’ ∈ reflect’ g a ==> a = a’
-- "if the reflective can reflect the input, then all of the things we get out are equal"
-- Unlike the other properties, this must use a generic generator so that we can
-- find out if there are things that cannot be generated by the reflective, but
-- can be reflected by it.
-- The issue with this property is that it often fails vacuously, because the precondition
-- is unlikely to hold. This makes it a challenge to test.
pureProj :: (Eq a) => Reflective a a -> a -> a -> QC.Property
pureProj g a a' = a' `elem` reflect' g a QC.==> a == a'

prop_sound :: QC.NonNegative Int -> QC.Property
prop_sound = soundness (bst (-10, 10))

prop_complete :: Tree -> Tree -> QC.Property
prop_complete = pureProj (bst (-10, 10))
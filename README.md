# Reflective Generators

Code Artifact for "Reflecting on Random Generation" ICFP23 paper.

## Requirements

This details requirements for using / running this artifact.

TODO flesh out as we make VM.
  Haskell, QC, etc.
  Python

## Code Tour

This will take you through what code we have, in reference to what appears in the paper.

> - `analysis/`
>   * `json/` _contains 10 JSONs for IFH experiment (Figure 7)_
>   * `shrinks/` _used to collect Hypothesis experiment results for Table 1_
>   * `cluster.py` - TODO (Harry) say what this does
>   * `json_analysis.ipynb` - TODO (Harry) say what this does
>   * `weighted.json` - generated by IFH experiment (Figure 7)
>   * `unweighted.json` - generated by IFH experiment (Figure 7)
> - `app/` _contains main file for Hypothesis experiment (Table 1)_
> - `json-app/` _contains main file for IFH experiment (Figure 7)_
> - `package-json-app/` _contains main file for realistic shrinking example (Section 6.2)_
> - `src/`
>   * `Reflectives.hs` - the main definitions inc:
>     - Fig 1. `bst` example
>     - Fig 2. definitions
>     - `comap`
>     - `R` / `Reflective`
>     - DSL for creating Reflective Generators
>   * `Interps.hs` - the interpretations of Reflective Generators inc:
>     - `generate` (Fig 4)
>     - `reflect` (Fig 5)
>     - `choices`
>     - `genWithWeights` (renamed to `weighted`)
>     - completers / producers
>   * `Choices.hs` - code specific to the shrinking and choices interps
>   * `FanOut.hs` - examples of the fan out property
>   * `Nats.hs` - examples of generator overlap (Fig 6)
>   * `PolymorphicInterp.hs` - Interpretation of a Reflective Generator as a generic PMP
>   * `Examples/`
>     - `Hypothesis/` _contains the Reflective Generators for the Hypothesis experiment (Table 1)_
>     - `Hypothesis.hs` - Hypothesis experiment code
>     - `JSON.hs` - defines a Reflective Generator for JSOn files inc `withHashCode`, renamed to `withChecksum`
>     - `PackageJSON.hs` - defines a Reflective Generator 'package' for package.json files
>     - `STLC.hs` - defines a Reflective Generator for the STLC
>     - `SystemF.hs` - defines a Reflective Generator for the SystemF
>     - `SystemFImplementation.hs` - contains an implementation of SystemF
> - `test/` _contains testing file to demonstrate testing correctness of Reflective Generators inc:_
>   * Def 2: soundness
>   * Def 5: pure proj
>   * Def 6: externally sound
>   * Def 7: externally complete
> - then at the tip level we also have Haskell project stuff:
>   * `package.yaml`
>   * `reflective-minimal.cabal`
>   * `Setup.hs`
>   * `stack.yaml`
>   * `stack.yaml.lock`
> - and some generic project stuff:
>   * `README.md`
>   * `LICENSE`
>   * `.gitignore`

TODOs
  - TODO (Harry) what do we wanna do with the demo.json?
  - Change String -> Choice, and Choice -> Maybe Choice (in code and paper)
  - add missing things (look at old repo, they are probs there)
    * gen that excludes the parse trees with a divide-by-zero error:
    * STLC reflective where annnotation is typeOf
    * noAnn


## Recreating Results

This will provide a step-by-step as to how to recreate the following results from our paper:
  1. Testing the correctness of Reflective Generators (Section 4.1 _Correctness of a Reflective Generator._)
  2. Analysis of IFH-style generator (Figure 7)
  3. Replicating the Hypothesis Experiment to analyse the Shrinking of Reflective Generators (Table 1)
  4. Using our of shrinking JSON files (Section 6.2 _A Realistic Example_)

### 1. Testing the correctness of Reflective Generators

Run the following command from the root directory of this project:
```bash
cabal test
```

### 2. Analysis of IFH-style generator

TODO (Harry): Please fill this in, cos while I can run the Haskell, I don't even have Python installed / haven't used it in 3 years.
Are both cluster.py and the python book needed?

### 3. Replicating the Hypothesis Experiment to analyse the Shrinking of Reflective Generators (Table 1)

Run the following command from the root directory of this project:
```bash
cabal run reflective-minimal-exe
```
Note that this is slow, and that the output is printed to the terminal in format:
```
experiment: unshrink mean (unshrink stddev range) & QC.genericShrink mean (QC.genericShrink stddev range) & reflective mean (reflective stddev range)
```
e.g.
```
heap: 15.06 (6.74--23.38) & 9.10 (8.23--9.97) & 9.18 (7.96--10.39)
```
where the first value is the unshrunk example, the second is the result of QuickCheck's generic shrink, and the last is the result of the Reflective Generator's shrink.

(Note that the Hypothesis numbers in the paper are not re-run, but taken directly from their experiment.)

### 4. Using our of shrinking JSON files

TODO (Harry): I can't actually get this working. I've run:
```
cabal run package-json-exe demo.json
```
then pasted in demo.json without new lines:
```
{"name": "reflective-generators","description": "What a great project","scripts": {"start": "node ./src/server.js","build": "babel ./src --out-dir ./dist","test": "mocha --compilers js:babel-core/register --require ./test/setup.js --recursive ./test"},"repository": {"type": "git","url": "https://example.com"},"keywords": ["reflective","generators"],"author": "test","license": "mit","devDependencies": {"babel-cli": "^6.24.1","babel-core": "^6.24.1","babel-preset-es2015": "^6.24.1"},"dependencies": {"express": "^4.15.3","reflective": "^0.0.1"}}
```

But `choices` returns the empty list. I tried removing ` --compilers js:babel-core/register --require ./test/setup.js --recursive` from the `test` field, to make it match the one in the paper, but that does nothing. I've had a look at the generator too and I can't see where it is going wrong.
I also wonder if we should hardcode in to read in `demo.json` using `readFile` cos `getContents` is more work for the user.
